---
- name: Deploy the stack
  hosts: localhost
  tasks:

  - name: Deploy PKI
    when: "stack.pki.enabled | bool == true"
    block:
    - name: Create and label the PKI namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.pki.ns }}"
            labels:
              istio-injection: enabled
    - name: Download the cert-manager CRDs
      ansible.builtin.get_url:
        url: https://github.com/cert-manager/cert-manager/releases/download/v1.17.1/cert-manager.crds.yaml
        dest: "{{ dist_dir }}/cert-manager-crds.yaml"
    - name: Apply the cert-manager CRDs
      kubernetes.core.k8s:
        state: present
        apply: true
        src: "{{ dist_dir }}/cert-manager-crds.yaml"
    - name: Create a secret from the local CA files
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: cert-manager-ca
            namespace: "{{ stack.pki.ns }}"
          data:
            tls.crt: "{{ lookup('ansible.builtin.file', '{{ pki_dir }}/ca.pem') | b64encode }}"
            tls.key: "{{ lookup('ansible.builtin.file', '{{ pki_dir }}/ca.key') | b64encode }}"
    - name: Declare the local CA as an issuer
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: ca-issuer
            namespace: "{{ stack.pki.ns }}"
          spec:
            ca:
              secretName: cert-manager-ca
    - name: Deploy cert-manager
      kubernetes.core.helm:
        name: cert-manager
        create_namespace: true
        release_namespace: "{{ stack.pki.ns }}"
        chart_ref: "{{ cert_manager_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            gateway_api_experimental: "{{ cluster.gateway_api_experimental | bool }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          edge:
            name: "{{ stack.edge.name }}"
            ns: "{{ stack.edge.ns }}"
          overrides:
            image:
              repository: "{{ host.registry.name }}:5000/jetstack/cert-manager-controller"
            webhook:
              image:
                repository: "{{ host.registry.name }}:5000/jetstack/cert-manager-webhook"
            cainjector:
              image:
                repository: "{{ host.registry.name }}:5000/jetstack/cert-manager-cainjector"
            acmesolver:
              image:
                repository: "{{ host.registry.name }}:5000/jetstack/cert-manager-acmesolver"
            startupapicheck:
              image:
                repository: "{{ host.registry.name }}:5000/jetstack/cert-manager-startupapicheck"
            namespace: "{{ stack.pki.ns }}"
            config:
              enableGatewayAPI: "{{ cluster.gateway_api | bool }}"
            prometheus:
              enabled: "{{ stack.prometheus.enabled | bool }}"

  - name: Deploy Edge
    when: "stack.edge.enabled | bool == true"
    block:
    - name: Create and label the Edge namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.edge.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy Edge Ingress
      ansible.builtin.import_role:
        name: mrmat.kube_eng.edge
      vars:
        kind: "{{ stack.edge.kind }}"
        ns: "{{ stack.edge.ns }}"
        cluster_name: "{{ cluster.name }}"
        config_file: "{{ dist_dir }}/edge.yaml"

  - name: Deploy Prometheus
    when: "stack.prometheus.enabled | bool == true"
    block:
    - name: Create and label the Prometheus namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.prometheus.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the Prometheus Helm Chart
      kubernetes.core.helm:
        name: prometheus
        create_namespace: false
        release_namespace: "{{ stack.prometheus.ns }}"
        chart_ref: "{{ prometheus_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          route:
            hostname: "{{ stack.prometheus.hostname }}"
          overrides:
            prometheus:
              image: "{{ host.registry.name }}:5000/prometheus-operator/prometheus-config-reloader"
            server:
              image:
                repository: "{{ host.registry.name }}:5000/prometheus/prometheus"
            kube-state-metrics:
              global:
                imageRegistry: "{{ host.registry.name }}:5000"
              image:
                registry: "{{ host.registry.name }}:5000"
            prometheus-node-exporter:
              global:
                imageRegistry: "{{ host.registry.name }}:5000"
              image:
                registry: "{{ host.registry.name }}:5000"

  - name: Deploy Alloy
    when: "stack.alloy.enabled | bool == true"
    block:
    - name: Create and label the Alloy namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.alloy.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the Alloy Helm Chart
      kubernetes.core.helm:
        name: alloy
        create_namespace: false
        release_namespace: "{{ stack.alloy.ns }}"
        chart_ref: "{{ alloy_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          overrides:
            image:
              registry: "{{ host.registry.name }}:5000"
            configReloader:
              image:
                registry: "{{ host.registry.name }}:5000"

  - name: Deploy Loki
    when: "stack.loki.enabled | bool == true"
    block:
    - name: Create and label the Loki namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.loki.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the Loki Helm chart
      kubernetes.core.helm:
        name: loki
        create_namespace: false
        release_namespace: "{{ stack.loki.ns }}"
        chart_ref: "{{ loki_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"

  - name: Deploy KeyCloak
    when: "stack.keycloak.enabled | bool == true"
    block:
    - name: Create and label the KeyCloak namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.keycloak.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the KeyCloak Operator
      kubernetes.core.k8s:
        src: "{{ item }}"
        namespace: "{{ stack.keycloak.ns }}"
        apply: true
        wait: true
        state: present
      loop:
      - https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.2.2/kubernetes/keycloaks.k8s.keycloak.org-v1.yml
      - https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.2.2/kubernetes/keycloakrealmimports.k8s.keycloak.org-v1.yml
      - https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/26.2.2/kubernetes/kubernetes.yml
    - name: Create a keycloak user in PostgreSQL
      community.postgresql.postgresql_user:
        login_host: localhost
        login_port: "{{ host.postgresql.port | int }}"
        login_user: postgres
        login_password: "{{ admin_password }}"
        login_db: postgres
        name: keycloak
        password: "{{ admin_password }}"
        comment: "Keycloak DB User"
        state: present
      environment:
        PGOPTIONS: "-c password_encryption=scram-sha-256"
    - name: Create a database for Keycloak in PostgreSQL
      community.postgresql.postgresql_db:
        login_host: localhost
        login_port: "{{ host.postgresql.port | int }}"
        login_user: postgres
        login_password: "{{ admin_password }}"
        name: keycloak
        owner: keycloak
        comment: "Keycloak Database"
        encoding: UTF-8
        state: present
    - name: Deploy the KeyCloak Helm Chart
      kubernetes.core.helm:
        name: keycloak
        create_namespace: true
        release_namespace: "{{ stack.keycloak.ns }}"
        chart_ref: "{{ keycloak_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          keycloak:
            admin_password: "{{ admin_password }}"
            db_password: "{{ admin_password }}"
            db_host: "{{ host.postgresql.name }}"
            db_port: "{{ host.postgresql.port }}"
          route:
            hostname: "{{ stack.keycloak.hostname }}"

  - name: Deploy Grafana
    when: "stack.grafana.enabled | bool == true"
    block:
    - name: Create and label the Grafana namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.grafana.ns }}"
            labels:
              istio-injection: enabled
    - name: Register Grafana in Keycloak
      community.general.keycloak_client:
        auth_keycloak_url: "https://{{ stack.keycloak.hostname }}.{{ cluster_name }}.{{ cluster.domain }}"
        auth_realm: master
        auth_username: admin
        auth_password: "{{ admin_password }}"
        client_id: "{{ stack.grafana.client_id }}"
        name: "{{ stack.grafana.client_id }}"
        description: "Kube Eng :: Grafana"
        enabled: true
        protocol: openid-connect
        public_client: false
        client_authenticator_type: client-secret
        secret: "{{ admin_password }}"
        root_url: "https://{{ stack.grafana.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/"
        base_url: "https://{{ stack.grafana.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/"
        admin_url: "https://{{ stack.grafana.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/"
        redirect_uris:
        - "https://{{ stack.grafana.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/login/generic_oauth"
        standard_flow_enabled: true
        implicit_flow_enabled: false
        direct_access_grants_enabled: true
        default_client_scopes:
        - email
        - offline_access
        - profile
        - roles
        # TODO: Make Ansible trust the generated PKI CA certificate
        validate_certs: false
    - name: Register Grafana Viewer role
      community.general.keycloak_role:
        auth_keycloak_url: "https://{{ stack.keycloak.hostname }}.{{ cluster_name }}.{{ cluster.domain }}"
        auth_realm: master
        auth_username: admin
        auth_password: "{{ admin_password }}"
        name: Viewer
        description: Grafana Viewers
        client_id: "{{ stack.grafana.client_id }}"
        state: present
        # TODO: Make Ansible trust the generated PKI CA certificate
        validate_certs: false
    - name: Register Grafana Editor role
      community.general.keycloak_role:
        auth_keycloak_url: "https://{{ stack.keycloak.hostname }}.{{ cluster_name }}.{{ cluster.domain }}"
        auth_realm: master
        auth_username: admin
        auth_password: "{{ admin_password }}"
        name: Editor
        description: Grafana Editors
        client_id: "{{ stack.grafana.client_id }}"
        state: present
        # TODO: Make Ansible trust the generated PKI CA certificate
        validate_certs: false
    - name: Register Grafana Admin role
      community.general.keycloak_role:
        auth_keycloak_url: "https://{{ stack.keycloak.hostname }}.{{ cluster_name }}.{{ cluster.domain }}"
        auth_realm: master
        auth_username: admin
        auth_password: "{{ admin_password }}"
        name: Admin
        description: Grafana Admins
        client_id: "{{ stack.grafana.client_id }}"
        state: present
        # TODO: Make Ansible trust the generated PKI CA certificate
        validate_certs: false
    - name: Install Grafana
      kubernetes.core.helm:
        name: grafana
        create_namespace: false
        release_namespace: "{{ stack.grafana.ns }}"
        chart_ref: "{{ grafana_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          route:
            hostname: "{{ stack.grafana.hostname }}"
          overrides:
            global:
              imageRegistry: "{{ host.registry.name }}:5000"
            adminUser: "{{ stack.grafana.admin_user }}"
            adminPassword: "{{ admin_password }}"
            envRenderSecret:
              GF_AUTH_GENERIC_OAUTH_CLIENT_ID: "{{ stack.grafana.client_id }}"
              GF_AUTH_GENERIC_OAUTH_CLIENT_SECRET: "{{ admin_password }}"
            grafana.ini:
              server:
                root_url: "https://{{ stack.grafana.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/"
              auth.generic_oauth:
                auth_url: "https://{{ stack.keycloak.hostname }}.{{ cluster_name }}.{{ cluster.domain }}/realms/master/protocol/openid-connect/auth"
                token_url: "http://keycloak-service.{{ stack.keycloak.ns }}.svc.cluster.local:8080/realms/master/protocol/openid-connect/token"
                api_url: "http://keycloak-service.{{ stack.keycloak.ns }}.svc.cluster.local:8080/realms/master/protocol/openid-connect/userinfo"
            datasources:
              datasources.yaml:
                apiVersion: 1
                datasources:
                - name: Prometheus
                  type: prometheus
                  url: "http://prometheus.{{ stack.prometheus.ns }}.svc.cluster.local"
                  isDefault: true

  - name: Deploy Jaeger
    when: "stack.jaeger.enabled | bool == true"
    block:
    - name: Create and label the Jaeger namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.jaeger.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the OpenTelemetry Operator
      kubernetes.core.helm:
        name: otel-operator
        create_namespace: false
        release_namespace: "{{ stack.jaeger.ns }}"
        chart_ref: open-telemetry/opentelemetry-operator
        wait: true
        values:
          manager:
            collectorImage:
              repository: otel/opentelemetry-collector-k8s
    - name: Deploy the Jaeger Helm Chart
      kubernetes.core.helm:
        name: jaeger
        create_namespace: false
        release_namespace: "{{ stack.jaeger.ns }}"
        chart_ref: "{{ jaeger_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          route:
            hostname: "{{ stack.jaeger.hostname }}"

  - name: Deploy Kiali
    when: "stack.kiali.enabled | bool == true"
    block:
    - name: Create and label the Kiali namespace
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ stack.kiali.ns }}"
            labels:
              istio-injection: enabled
    - name: Deploy the Kiali Operator
      kubernetes.core.helm:
        name: kiali-operator
        create_namespace: false
        release_namespace: "{{ stack.kiali.ns }}"
        chart_ref: kiali/kiali-operator
        wait: true
        values:
          cr:
            create: false
          image:
            repo: "{{ host.registry.name }}:5000/kiali/kiali-operator"
    - name: Deploy the Kiali Helm Chart
      kubernetes.core.helm:
        name: kiali
        create_namespace: false
        release_namespace: "{{ stack.kiali.ns }}"
        chart_ref: "{{ kiali_chart }}"
        wait: true
        values:
          cluster:
            control_plane_nodes: "{{ cluster.control_plane_nodes | int }}"
            worker_nodes: "{{ cluster.worker_nodes | int }}"
            mesh: "{{ cluster.mesh }}"
            istio_profile: "{{ cluster.istio_profile }}"
            gateway_api: "{{ cluster.gateway_api | bool }}"
            edge_ns: "{{ cluster.edge_ns }}"
            edge: "{{ cluster.edge_name }}"
            name: "{{ cluster_name }}"
            domain: "{{ cluster.domain }}"
          route:
            hostname: "{{ stack.kiali.hostname }}"
          integrations:
            tracing:
              internal: "http://jaeger-collector-headless.{{ stack.jaeger.ns }}.svc.cluster.local:16686/jaeger"
              external: "https://{{ stack.jaeger.hostname }}.{{ cluster_name }}.{{ cluster.domain }}"
            grafana:
              auth:
                type: 'basic'
                username: admin
                password: "{{ admin_password }}"
