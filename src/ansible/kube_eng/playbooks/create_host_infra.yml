---
- name: Create and configure the host infrastructure
  hosts: localhost
  tasks:
  - name: Template the resolver configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.bind_configuration
    vars:
      resolver_executable: "{{ host.tools.named }}"
      resolver_dir: "{{ dist_dir }}/resolver"
      forwarder: "{{ host.resolver.forwarder }}"
      domain: "{{ cluster_name }}.k8s"
      resolver_key: "{{ admin_password }}"

  - name: Template the cloud-provider-kind configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.cloud_provider_kind_configuration
    vars:
      cloud_provider_kind_url: "{{ host.cloud_provider_kind.url }}"
      cloud_provider_kind_dir: "{{ dist_dir }}/cloud-provider-kind"

  - name: Template the cloud-provider-mdns configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.cloud_provider_mdns_configuration
    vars:
      cloud_provider_mdns_executable: "{{ cloud_provider_mdns }}"
      cloud_provider_mdns_dir: "{{ dist_dir }}/cloud-provider-mdns"
      cloud_provider_mdns_user: "{{ user_id }}"

  - name: Create PKI infrastructure
    block:
    - name: Create a directory for PKI
      ansible.builtin.file:
        path: "{{ dist_dir }}/pki"
        state: directory
    - name: Create a private key for the local CA
      community.crypto.openssl_privatekey:
        path: "{{ dist_dir }}/pki/ca.key"
        type: ECC
        curve: secp256r1
        return_content: true
        state: present
    - name: Generate a CSR for the local CA
      community.crypto.openssl_csr:
        path: "{{ dist_dir }}/pki/ca.csr"
        privatekey_path: "{{ dist_dir }}/pki/ca.key"
        common_name: "{{ cluster_name }} Local CA"
        key_usage_critical: true
        key_usage:
        - keyCertSign
        - cRLSign
        basic_constraints_critical: true
        basic_constraints:
        - "CA:TRUE"
        - "pathlen:1"
    - name: Create a self-signed local CA
      community.crypto.x509_certificate:
        path: "{{ dist_dir }}/pki/ca.pem"
        privatekey_path: "{{ dist_dir }}/pki/ca.key"
        csr_path: "{{ dist_dir }}/pki/ca.csr"
        provider: selfsigned
        return_content: true

  - name: Create a local PostgreSQL database
    when: host.postgresql.enabled == true
    block:
    - name: Create a volume for PostgreSQL
      community.docker.docker_volume:
        name: "{{ host.postgresql.volume.name }}"
        state: present
    - name: Create a PostgreSQL container
      community.docker.docker_container:
        name: "{{ host.postgresql.name }}"
        image: "{{ host.postgresql.image }}"
        restart: true
        ports:
        - "127.0.0.1:{{ host.postgresql.port | int }}:5432"
        mounts:
        - source: "{{ host.postgresql.volume.name }}"
          target: /var/lib/postgresql/data
        networks:
        - name: kind
          aliases: "{{ host.postgresql.name }}"
        env:
          POSTGRES_PASSWORD: "{{ admin_password }}"
          PGDATA: /var/lib/postgresql/data
        restart_policy: always
        state: healthy

  - name: Create an airgapped registry
    when: host.registry.enabled == true
    block:
    - name: Create an airgapped registry volume
      community.docker.docker_volume:
        name: "{{ host.registry.volume.name }}"
        state: present
    - name: Create an airgapped registry
      community.docker.docker_container:
        name: "{{ host.registry.name }}"
        image: "{{ host.registry.image }}"
        restart: true
        ports:
        - "127.0.0.1:{{ host.registry.port | int }}:5000"
        mounts:
        - source: "{{ host.registry.volume.name }}"
          target: /var/lib/registry
        networks:
        - name: kind
          aliases: "{{ host.registry.name }}"
        restart_policy: always
        state: started
