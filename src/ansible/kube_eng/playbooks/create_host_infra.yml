---
- name: Create and configure the host infrastructure
  hosts: localhost
  tasks:
  - name: Create PKI infrastructure
    when: "stack.cert_manager.enabled | bool == true"
    block:
    - name: Create a directory for PKI
      ansible.builtin.file:
        path: "{{ pki_dir }}"
        state: directory
    - name: Create a private key for the local CA
      community.crypto.openssl_privatekey:
        path: "{{ pki_dir }}/ca.key"
        type: ECC
        curve: secp256r1
        return_content: true
        state: present
    - name: Generate a CSR for the local CA
      community.crypto.openssl_csr:
        path: "{{ pki_dir }}/ca.csr"
        privatekey_path: "{{ pki_dir }}/ca.key"
        common_name: "{{ cluster_name }} Local CA"
        key_usage_critical: true
        key_usage:
        - keyCertSign
        - cRLSign
        basic_constraints_critical: true
        basic_constraints:
        - "CA:TRUE"
        - "pathlen:1"
    - name: Create a self-signed local CA
      community.crypto.x509_certificate:
        path: "{{ pki_dir }}/ca.pem"
        privatekey_path: "{{ pki_dir }}/ca.key"
        csr_path: "{{ pki_dir }}/ca.csr"
        provider: selfsigned
        return_content: true

  - name: Template the BIND resolver configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.bind_configuration
    vars:
      bind_executable: "{{ host_tool_named }}"
      bind_dir: "{{ dist_dir }}/bind"
      forwarders: "{{ host.bind.forwarders }}"
      domain: "{{ cluster_name }}.k8s"
      bind_key: "{{ admin_password }}"

  - name: Template the cloud-provider-kind configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.cloud_provider_kind_configuration
    vars:
      cloud_provider_kind_url: "{{ host.cloud_provider_kind.url }}"
      cloud_provider_kind_dir: "{{ dist_dir }}/cloud-provider-kind"

  - name: Template the cloud-provider-mdns configuration
    ansible.builtin.import_role:
      name: mrmat.kube_eng.cloud_provider_mdns_configuration
    vars:
      cloud_provider_mdns_executable: "{{ cloud_provider_mdns }}"
      cloud_provider_mdns_dir: "{{ dist_dir }}/cloud-provider-mdns"
      cloud_provider_mdns_user: "{{ user_id }}"

  - name: Create a local PostgreSQL database
    when: host.postgresql.enabled == true
    block:
    - name: Create a volume for PostgreSQL
      community.docker.docker_volume:
        name: "{{ host.postgresql.volume.name }}"
        state: present
    - name: Create a PostgreSQL container
      community.docker.docker_container:
        name: "{{ host.postgresql.name }}"
        image: "{{ host.postgresql.image }}"
        restart: true
        ports:
        - "127.0.0.1:{{ host.postgresql.port | int }}:5432"
        mounts:
        - source: "{{ host.postgresql.volume.name }}"
          target: /var/lib/postgresql/data
        networks:
        - name: kind
          aliases: "{{ host.postgresql.name }}"
        env:
          POSTGRES_PASSWORD: "{{ admin_password }}"
          PGDATA: /var/lib/postgresql/data
        restart_policy: always
        state: healthy

  - name: Create a local MinIO server
    when: host.minio.enabled == true
    block:
    - name: Create a volume for Minio
      community.docker.docker_volume:
        name: "{{ host.minio.volume.name }}"
        state: present
    - name: Create a MinIO container
      community.docker.docker_container:
        name: "{{ host.minio.name }}"
        image: "{{ host.minio.image }}"
        restart: true
        ports:
        - "127.0.0.1:{{ host.minio.port | int }}:9000"
        - "127.0.0.1:{{ host.minio.console.port | int }}:9001"
        mounts:
        - source: "{{ host.minio.volume.name }}"
          target: /data
        networks:
        - name: kind
          aliases: "{{ host.minio.name }}"
        env:
          MINIO_ROOT_USER: admin
          MINIO_ROOT_PASSWORD: "{{ admin_password }}"
        command: "server /data --console-address ':9001'"
        restart_policy: always
        state: healthy

  - name: Preheat k8s yaml files for later
    block:
    - name: Create a directory for preheated files
      ansible.builtin.file:
        path: "{{ dist_dir }}/preheat"
        state: directory
    - name: Download the CRD for cert-manager
      ansible.builtin.get_url:
        url: "{{ stack.cert_manager.crd }}"
        dest: "{{ dist_dir }}/preheat/cert-manager-crds.yaml"
    - name: Download the Gateway-API CRDs
      ansible.builtin.get_url:
        url: "{{ stack.gateway_api.crd }}"
        dest: "{{ dist_dir }}/preheat/gateway-api-crds.yaml"
    - name: Download the Experimental Gateway-API CRDs
      ansible.builtin.get_url:
        url: "{{ stack.gateway_api.crd_experimental }}"
        dest: "{{ dist_dir }}/preheat/experimental-gateway-api-crds.yaml"
    - name: Download the KeyCloak Operator CRDs
      ansible.builtin.get_url:
        url: "https://raw.githubusercontent.com/keycloak/keycloak-k8s-resources/{{ stack.keycloak.operator_version }}/kubernetes/{{ item }}"
        dest: "{{ dist_dir }}/preheat/{{ item }}"
      loop: "{{ stack.keycloak.operator_yaml }}"

  - name: Create an AirGap registry
    when: host.registry.enabled == true
    block:
    - name: Create an airgapped registry volume
      community.docker.docker_volume:
        name: "{{ host.registry.volume.name }}"
        state: present
    - name: Create an airgapped registry
      community.docker.docker_container:
        name: "{{ host.registry.name }}"
        image: "{{ host.registry.image }}"
        restart: true
        ports:
        - "127.0.0.1:{{ host.registry.port | int }}:5000"
        mounts:
        - source: "{{ host.registry.volume.name }}"
          target: /var/lib/registry
        networks:
        - name: kind
          aliases: "{{ host.registry.name }}"
        restart_policy: always
        state: started
    - name: Preheat the container image(s)
      ansible.builtin.include_role:
        name: mrmat.kube_eng.preheat_image
      vars:
        airgap_registry: "localhost:{{ host.registry.port }}"
        image: "{{ item.image }}"
      loop: "{{ preheat }}"
  - name: Preheat the kind node image
    community.docker.docker_image_pull:
      name: "docker.io/{{ cluster.node_image }}"

  # TODO: coredns wants to be read from another place
  - name: Bug - Make the coredns image available at the root of the airgap
    community.docker.docker_image_pull:
      name:  "localhost:{{ host.registry.port }}/coredns/coredns:v1.11.3"
  - name: Bug - Re-tag the coredns image
    community.docker.docker_image_tag:
      name: "localhost:{{ host.registry.port }}/coredns/coredns:v1.11.3"
      repository:
      - "localhost:{{ host.registry.port }}/coredns:v1.11.3"
  - name: Bug - Push the image into the air gapped repository
    community.docker.docker_image_push:
      name: "localhost:{{ host.registry.port }}/coredns"
      tag: v1.11.3
